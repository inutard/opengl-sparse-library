//test fragment shader

#version 130

const float EPS = 1e-8; // epsilon tolerance (anything below is a zero)

const int N = 4;     // 4x4 matrix, just for testing in low dimensions
const int nnz = N*N;  // current just a constant for testing purposes.

//note to self, add variables for number of non-zeros, max space allocated, etc.
//also optimize so the matrix below is assumed to be symmetric
struct csr_matrix { 
    int n, m;       // dimensions of matrix
    float x[nnz];    // non-zero values of sparse matrix
    int idx[nnz];        // row indices of CSC matrix
    int row[N+1];     // locations of rows of CSC matrix in m_x and m_idx array
};

float norm(float v[N]) {
    float res = 0;
    for (int i = 0; i < N; i++) {
        res += v[i]*v[i];
    }
    return sqrt(res);
}

// res[N] is an ugly hack to get around lack of pointers in GLSL 1.3
// things to fix after upgrading to GLSL 4.0+:
//  - change function below to use some sorted shared buffer or pointers
//  - remove globals
//  - add error checking
float result[N];
// mat_vec_prod : computes A*x and places the result in res.
void mat_vec_prod(csr_matrix A, float x[N]) {
    for (int i = 0; i < N; i++) {
        float row_prod = 0;
        for (int j = A.row[i]; j < A.row[i+1]; j++) {
            int r = A.idx[j];
            row_prod += A.x[j]*x[r];
        }
        result[i] = row_prod;
    }
}

const int iters = 3;   // number of iterations of lanczos
float alpha[iters+1],    // the main diagonal (alpha) and off diagonal (beta)
      beta[iters+1];     // of the lanczos matrix, T
// lanczos : computes the T matrix thats generated by lanczos on a symmetric matrix A
void lanczos(csr_matrix A) {
    // lanczos ordinarily produces matrices V and T s.t. AV = VT.
    // to make things simpler for now, we only compute T.
    // this means we only need to keep the last 2 columns of the V matrix.
    // v1 is the most recent column computed, v2 is the second most recent.
    float v1[N], v2[N]; // NTS: when we have GLSL 4.0, switch to multi-D arrays
    beta[0] = 0;
    
    // assign an initial vector to V, we'll always initialize
    // with the all 1's vector (normalized) for simplicity.
    for (int i = 0; i < N; i++) {
        v1[i] = 1/sqrt(N);
    }
    
    float w[N]; // the current column of V being computed
    float tmp[N]; // temporary work memory
    for (int i = 0; i < iters; i++) {
    
        // set w = A*V(i,:) if i = 0, otherwise
        //     w = A*V(i,:) - beta(i)*V(i-1,:)
        mat_vec_prod(A, v1);
        w = result;
        if (i > 0) {
            for (int j = 0; j < N; j++) {
                w[j] -= beta[i]*v2[j];
            }
        }
        
        // set alpha[i] = w'*V(i,:)
        alpha[i] = 0;
        for (int j = 0; j < N; j++) {
            alpha[i] += w[j]*v1[j];
        }
        
        // set w = w - alpha[i]*v1 (a step of gram-schmidt)
        for (int j = 0; j < N; j++) {
            w[j] -= alpha[i]*v1[j];
        }
        
        // set beta[i+1] = norm(w)
        beta[i+1] = norm(w);
        if (abs(beta[i+1]) < EPS) { 
            // a happy breakdown occured. currently no error code is 
            // thrown but this should be changed
            break;
        }
        
        for (int j = 0; j < N; j++) {
            v2[j] = w[j]/beta[i+1];
        }
        
        // swap v1 and v2 since the v2 computed above is now the
        // most recent column
        tmp = v1;
        v1 = v2;
        v2 = tmp;
    }
}


csr_matrix test_mat;

void main()
{
    
    for (int i = 0; i < (nnz+1)/2; i++) {
        test_mat.x[i] = 0.1*(i+1);
        test_mat.x[nnz-i-1] = 0.1*(i+1);
    }
    
    int cnt = 0;
    test_mat.row[0] = 0;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            test_mat.idx[cnt] = j;
            cnt++;
        }
        test_mat.row[i+1] = cnt;
    }
    
    lanczos(test_mat);
	gl_FragColor = vec4(alpha[0], alpha[1], beta[2], beta[3]);    
}
